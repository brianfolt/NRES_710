hist(allfrogs.bodysize,main="",xlab="SVL (mm)")   # plot out histogram
truemean_SVL <- mean(allfrogs.bodysize)           # the 'parameter'
truemean_SVL
mysample <- sample(allfrogs.bodysize,10)    # take sample of size 10 (10 frogs measured)
mean(mysample)   # compute the sample mean
mysample <- sample(allfrogs.bodysize,20)    # take sample of size 20 (20 frogs measured)
mean(mysample)   # compute the sample mean
lotsofsamples <- list()
for(s in 1:5000){
lotsofsamples[[paste0("sample",s)]] <- sample(allfrogs.bodysize,30)    # take sample of size 30 (20 frogs measured)
}
lotsofsamples$sample1
lotsofsamples$sample99
lotsofsamples$sample732
samplemeans <- sapply(lotsofsamples,mean)
hist(samplemeans,xlab="mean body size (n=30)")
hist(rbinom(10000,1,.5),xlab="N heads out of 1")
par(mfrow=c(3,2))
for(i in seq(2,12,2)){
hist(rbinom(10000,i,.5),main=paste0("sample size = ",i),xlab=sprintf("N heads out of %s",i))
}
hist(rbinom(10000,1000,.5),xlab="N heads out of 1")
# pseudoreplication demonstration
meansize.allfrogs <- 1.5    # population mean
sdsize.allfrogs <- 0.5     # population sd
sdsize.amongpond <- 0.44   # standard deviation among ponds
nponds <- 5000   # total number of ponds in the population
nfrogs.perpond <- 1000    # 1000 frogs in each pond
pondmeans <- rnorm(nponds,meansize.allfrogs,sdsize.amongpond)
# hist(pondmeans)
allfrogs <- sapply(pondmeans, function(t) rnorm(nfrogs.perpond,t,sqrt(sdsize.allfrogs^2-sdsize.amongpond^2)) )
rownames(allfrogs) <- paste0("frog",1:(nfrogs.perpond))
colnames(allfrogs) <- paste0("pond",1:nponds)
# confirm that population mean and standard deviation are as specified
sd(allfrogs)
mean(allfrogs)
nponds.sampled <- 2
nsamp.perpond <- 50
ponds.sampled <- sample(1:nponds,nponds.sampled)
frogs.sampled <- replicate(nponds.sampled,sample(1:nfrogs.perpond,nsamp.perpond))
thissamp <- sapply(1:nponds.sampled,function(t) allfrogs[frogs.sampled[,t],ponds.sampled[t]])
rownames(thissamp) <- paste0("frog",1:(nsamp.perpond))
colnames(thissamp) <- paste0("pond",1:nponds.sampled)
head(thissamp)
test <- t.test(as.vector(thissamp),mu=1.5,alternative="greater")
test
means <- numeric(1000)
means.ind <- numeric(1000)
ttest <- numeric(1000)
ttest.ind <- numeric(1000)
for(scenario in 1:1000){
ponds.sampled <- sample(1:nponds,nponds.sampled)
frogs.sampled <- replicate(nponds.sampled,sample(1:nfrogs.perpond,nsamp.perpond))
thissamp <- sapply(1:nponds.sampled,function(t) allfrogs[frogs.sampled[,t],ponds.sampled[t]])
thissamp.ind <- matrix(sample(allfrogs,nsamp.perpond*nponds.sampled),ncol=nponds.sampled)
means[scenario] <- mean(thissamp)
means.ind[scenario] <- mean(thissamp.ind)
test <- t.test(as.vector(thissamp),mu=1.5,alternative="greater")
test.ind <- t.test(as.vector(thissamp.ind),mu=1.5,alternative="greater")
ttest[scenario] <- test$p.value
ttest.ind[scenario] <- test.ind$p.value
}
layout(matrix(1:2,nrow=1))
hist(means,xlim=c(0,3))
hist(means.ind,xlim=c(0,3))
length(which(ttest<0.05))/1000
length(which(ttest.ind<0.05))/1000
#######
# Sampling distribution: the sample mean
mysample <- c(4.1,3.5,3.7,6.6,8.0,5.4,7.3,4.4)
mysample
n <- length(mysample)    # sample size
sample.mean <- mean(mysample)  # sample mean
sample.stdev <- sd(mysample)   # sample standard deviation (r uses denominator of n-1 by default!)
std.error <- sample.stdev/sqrt(n)
std.error
sampdist <- function(x){dt((x-sample.mean)/std.error,n-1)}
curve(sampdist,0,11,ylab="probability density",xlab="value",main="sampling distribution for the sample mean!")
abline(v=sample.mean,col="green",lwd=3)
confint <- c(sample.mean+std.error*qt(0.025,n-1),sample.mean+std.error*qt(0.975,n-1))
abline(v=confint,col="blue",lty=2)
#######
# Sampling distribution: the sample mean #2 (brute force simulation version)
mysample <- c(4.1,1.5,3.7,6.6,8.0,4.5,5.3,4.4)
mysample
n <- length(mysample)    # sample size
sample.mean <- mean(mysample)  # sample mean
sample.stdev <- sd(mysample)   # sample standard deviation (r uses denominator of n-1 by default!)
simulated.samples <- list()
for(s in 1:10000){
sd1 <- sqrt(sum((sample(mysample,length(mysample)-1,replace = T)-sample.mean)^2)/(length(mysample)-2))  # account for unknown standard deviation
simulated.samples[[paste0("sample ",s)]] <- rnorm(n,sample.mean,sd1)
}
sampling.distribution <- sapply(simulated.samples,mean)
plot(density(sampling.distribution),xlim=c(0,11),ylab="probability density",xlab="value",main="sampling distribution for the sample mean!",lwd=2)    # plot the brute-force sampling distribution
hist(sampling.distribution,add=T,freq=F)
par(new=T)
curve(sampdist,0,11,xlim=c(0,11),xaxt="n",yaxt="n",xlab="",ylab="",col="red",lwd=2)  # official sampling distribution
abline(v=sample.mean,col="green",lwd=3)
## Paired t-test example:
weightloss.data <- c(-10.4,-11.6,3.9,1.5,-0.3,-3.5 -10.0,-6.7,-6.1,-2.4,-6.0,2.3,0.1,-4.1,-3.2, -11.3,-3.2,-9.3,-7.5,-5.7,-0.1,0.0,-9.8,1.0,-11.9)
hist(weightloss.data,breaks=7)
mean.weightloss <- mean(weightloss.data)
null.weightloss <- 0
stdev.weightloss <- sd(weightloss.data)
sample.size <- length(weightloss.data)
std.error <- stdev.weightloss/sqrt(sample.size)
t.statistic <- (mean.weightloss-null.weightloss)/std.error
t.statistic
curve(dt(x,sample.size-1),-5.5,2)
abline(v=t.statistic,col="green",lwd=3)
t.crit <- qt(0.05,sample.size-1)    # 'critical value' of the t statistic- you can reject the null if your value is more extreme than this!
p=pt(t.statistic,sample.size-1)    # p value
p    # this is the p value
####### Alternative: use R's built in t test
t.test(weightloss.data,alternative = "less")   # should get the same p=value!
summary(weightloss.data)
mean.weightloss
std.error
curve(dt(x,sample.size),-4,4)
curve(dt(x,sample.size),-4,4,xaxt="n")
curve(dt(x,sample.size),-4,4,xaxt="n",xlab="weight loss",ylab="probability")
axis(1,at=seq(-4,4,2),labels = mean.weightloss+std.error*seq(-4,4,2) )
### confidence interval for weight loss data
summary(weightloss.data)
mean.weightloss    # mean weight loss
std.error          # standard error of weight loss
curve(dt(x,sample.size),-4,4,xaxt="n",xlab="weight loss",ylab="probability density")
axis(1,at=seq(-4,4,2),labels = mean.weightloss+std.error*seq(-4,4,2) )
### confidence interval for weight loss data
summary(weightloss.data)
mean.weightloss    # mean weight loss
std.error          # standard error of weight loss
curve(dt(x,sample.size),-4,4,xaxt="n",xlab="weight loss",ylab="probability density")
axis(1,at=seq(-4,4,2),labels = round(mean.weightloss+std.error*seq(-4,4,2),1) )
### confidence interval for weight loss data
summary(weightloss.data)
mean.weightloss    # mean weight loss
std.error          # standard error of weight loss
curve(dt(x,sample.size),-4,4,xaxt="n",xlab="weight loss",ylab="probability density")
axis(1,at=seq(-4,4,2),labels = round(mean.weightloss+std.error*seq(-4,4,2),1) )
abline(v=mean.weightloss,col="blue",lwd=3)
### confidence interval for weight loss data
summary(weightloss.data)
mean.weightloss    # mean weight loss
std.error          # standard error of weight loss
curve(dt(x,sample.size),-4,4,xaxt="n",xlab="weight loss",ylab="probability density")
axis(1,at=seq(-4,4,2),labels = round(mean.weightloss+std.error*seq(-4,4,2),1) )
abline(v=0,col="blue",lwd=3)
t.crit
t.crit <- qt(0.025,sample.size-1)    # for 95% confidence interval
t.crit
t.crit <- qt(0.975,sample.size-1)    # for 95% confidence interval
### confidence interval for weight loss data
# summary(weightloss.data)
#
# mean.weightloss    # mean weight loss
# std.error          # standard error of weight loss
curve(dt(x,sample.size),-4,4,xaxt="n",xlab="weight loss",ylab="probability density")
axis(1,at=seq(-4,4,2),labels = round(mean.weightloss+std.error*seq(-4,4,2),1) )
abline(v=0,col="blue",lwd=3)
t.crit <- qt(0.975,sample.size-1)    # for 95% confidence interval
abline(v=-1*t.crit,col="red",lty=2)
abline(v=1*t.crit,col="red",lty=2)
lower.bound <- mean.weightloss - t.crit*std.error
upper.bound <- mean.weightloss - t.crit*std.error
lower.bound
upper.bound
upper.bound <- mean.weightloss + t.crit*std.error
upper.bound
### confidence interval for weight loss data
# summary(weightloss.data)
#
# mean.weightloss    # mean weight loss
# std.error          # standard error of weight loss
curve(dt(x,sample.size),-4,4,xaxt="n",xlab="weight loss",ylab="probability density")
axis(1,at=seq(-4,4,2),labels = round(mean.weightloss+std.error*seq(-4,4,2),1) )
abline(v=0,col="blue",lwd=3)
t.crit <- qt(0.975,sample.size-1)    # for 95% confidence interval
abline(v=-1*t.crit,col="red",lty=2)
abline(v=1*t.crit,col="red",lty=2)
lower.bound <- mean.weightloss - t.crit*std.error
upper.bound <- mean.weightloss + t.crit*std.error
lower.bound
upper.bound
### confidence interval for weight loss data
# summary(weightloss.data)
#
# mean.weightloss    # mean weight loss
# std.error          # standard error of weight loss
curve(dt(x,sample.size),-4,4,xaxt="n",xlab="weight loss",ylab="probability density")
axis(1,at=seq(-4,4,2),labels = round(mean.weightloss+std.error*seq(-4,4,2),1) )
abline(v=0,col="blue",lwd=3)
t.crit <- qt(0.975,sample.size-1)    # for 95% confidence interval
abline(v=-1*t.crit,col="red",lty=2)
abline(v=1*t.crit,col="red",lty=2)
lower.bound <- mean.weightloss - t.crit*std.error
upper.bound <- mean.weightloss + t.crit*std.error
lower.bound
upper.bound
rmd2rscript("INTRO.Rmd")
rmd2rscript("LECTURE1.Rmd")
rmd2rscript("LECTURE1.Rmd")
rmd2rscript("LECTURE2.Rmd")
curve(dt(x,8),-4,4,xlab="possibilities",ylab='relative probability')
curve(dpois(x,2),0,8,xlab="possibilities",ylab='probability')
?curve
barplot(sapply(0:8,function(t) dpois(t,2)),xlab="possibilities",ylab='probability')
barplot(sapply(0:10,function(t) dpois(t,2)),xlab="possibilities",ylab='probability')
x <- barplot(sapply(0:10,function(t) dpois(t,2)),xlab="possibilities",ylab='probability')
## probability mass function example
x <- barplot(sapply(0:10,function(t) dpois(t,2)),xlab="possibilities",ylab='probability')
axis(1,at=x,labels=0:10)
## cumulative density function
curve(pt(x,df=8),-4,4,xlab="possibilities",ylab='cumulative probability')
## cumulative density function
# for continuous distribution
curve(pt(x,df=8),-4,4,xlab="possibilities",ylab='cumulative probability')
# for discrete distribution
x <- barplot(sapply(0:10,function(t) ppois(t,2)),xlab="possibilities",ylab='cumulative probability')
axis(1,at=x,labels=0:10)
rnorm(10)    # generate 10 random numbers from a standard normal distribution
rpois(8,18)  # generate 8 random numbers from a poisson distribution with mean=18
#################
# Probability distributions
mean <- 5
rpois(10,mean)    # note: the random numbers sampled from this distribution have no decimal component
# plot a discrete distribution!
xvals <- seq(0,15,1)
probs <- dpois(xvals,lambda=mean)
names(probs) <- xvals
barplot(probs,ylab="Probability",main="Poisson distribution (discrete)")
barplot(cumsum(probs),ylab="Cumulative Probability",main="Poisson distribution (discrete)")   # cumulative distribution
sum(probs)   # just to make sure it sums to 1!  Does it???
#################
# Probability distributions
mean <- 5
rpois(10,mean)    # note: the random numbers sampled from this distribution have no decimal component
# plot discrete probabilities of getting particular outcomes!
xvals <- seq(0,15,1)
probs <- dpois(xvals,lambda=mean)
names(probs) <- xvals
barplot(probs,ylab="Probability Mass",main="Poisson distribution (discrete)")
barplot(cumsum(probs),ylab="Cumulative Probability",main="Poisson distribution (discrete)")   # cumulative distribution
sum(probs)   # just to make sure it sums to 1!  Does it???
sum(probs)   # just to make sure it sums to 1!  Does it???
#########
# continuous distributions
shape1 = 0.5
shape2 = 0.5
rbeta(10,shape1,shape2)
curve(dbeta(x,shape1,shape2))   # probability density
curve(pbeta(x,shape1,shape2))   # cumulative distribution
integrate(f=dbeta,lower=0,upper=1,shape1=shape1,shape2=shape2)    # just to make sure it integrates to 1!!
rbeta(10,shape1,shape2)   # generate 10 random numbers from a continuous distribution
curve(dbeta(x,shape1,shape2))   # probability density function (PDF)
#########
# continuous distributions
shape1 = 0.5
shape2 = 0.5
rbeta(10,shape1,shape2)   # generate 10 random numbers from a continuous distribution
curve(dbeta(x,shape1,shape2),ylab="probability density",xlab="possibilities")   # probability density function (PDF)
curve(pbeta(x,shape1,shape2),ylab="cumulative probability",xlab="possibilities")   # cumulative distribution
integrate(f=dbeta,lower=0,upper=1,shape1=shape1,shape2=shape2)    # just to make sure it integrates to 1!!
## probability density function example
curve(dt(x,8),-4,4,xlab="possibilities",ylab='relative probability (prob density')
## probability density function example
curve(dt(x,8),-4,4,xlab="possibilities",ylab='relative probability (prob density)')
## quantile function
# for continuous distribution
curve(pt(x,df=8),-4,4,xlab="possibilities",ylab='cumulative probability')
# for discrete distribution
x <- barplot(sapply(0:10,function(t) ppois(t,2)),xlab="possibilities",ylab='cumulative probability')
axis(1,at=x,labels=0:10)
## quantile function
# for continuous distribution
curve(qt(x,df=8),0,1,xlab="cumulative probability",ylab='quantile')
# for discrete distribution
curve(qpois(x,4),0,1,xlab="cumulative probability",ylab='quantile')
rmd2rscript("INTRO.Rmd")
rmd2rscript("LECTURE1.Rmd")
rmd2rscript("LECTURE1.Rmd")
rmd2rscript("LECTURE2.Rmd")
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
sample.data <- rgamma(10,2,.1)
sample.data
sample.data <- rgamma(10,2,.1)
null.mean <- 10
sample.size <- length(sample.data)
sample.mean <- mean(sample.data)
sample.sd <- sd(sample.data)
std.err <- sample.sd/sqrt(sample.size)
t.stat <- (sample.mean-null.mean)/std.err
t.stat
qt(0.025,sample.size-1)
t.crit <- abs(qt(0.025,sample.size-1))
t.crit
p.val <- (1-pt(abs(t.stat),sample.size-1))*2
p.val
?t.test
t.test(sample.data,mu=null.mean)
sample.data.1 <- rnorm(15,55,10)
sample.data.2 <- rnorm(10,50,10)
sample.data.2 <- rnorm(10,45,10)
sample.size <- length(sample.data1) + length(sample.data2)
sample.data.1 <- rnorm(15,55,10)
sample.data.2 <- rnorm(10,45,10)
sample.size <- length(sample.data1) + length(sample.data2)
sample.sd1 <- sd(sample.data1)
sample.sd2 <- sd(sample.data2)
sample.size <- length(sample.data1) + length(sample.data2)
sample.mean1 <- mean(sample.data1)
sample.mean2 <- mean(sample.data2)
sample.sd1 <- sd(sample.data1)
sample.data.1 <- rnorm(15,55,10)
sample.data.2 <- rnorm(10,45,10)
sample.size <- length(sample.data1) + length(sample.data2)
sample.mean1 <- mean(sample.data1)
sample.data.1 <- rnorm(15,55,10)
sample.data.2 <- rnorm(10,45,10)
sample.size <- length(sample.data.1) + length(sample.data.2)
sample.mean1 <- mean(sample.data.1)
sample.mean2 <- mean(sample.data.2)
sample.sd1 <- sd(sample.data.1)
sample.sd2 <- sd(sample.data.2)
sample.size.2 <- length(sample.data.2)
sample.sd.pooled <- sqrt(((sample.size.1-1)*sample.sd1^2 + (sample.size.2-1)*sample.sd2^2)/(sample.size.pooled-2))
sample.mean1 <- mean(sample.data.1)
sample.mean2 <- mean(sample.data.2)
sample.sd1 <- sd(sample.data.1)
sample.sd2 <- sd(sample.data.2)
sample.sd.pooled <- sqrt(((sample.size.1-1)*sample.sd1^2 + (sample.size.2-1)*sample.sd2^2)/(sample.size.pooled-2))
sample.size.1 <- length(sample.data.1)
sample.size.2 <- length(sample.data.2)
sample.sd.pooled <- sqrt(((sample.size.1-1)*sample.sd1^2 + (sample.size.2-1)*sample.sd2^2)/(sample.size.pooled-2))
sample.size.pooled <- length(sample.data.1) + length(sample.data.2)
sample.sd.pooled <- sqrt(((sample.size.1-1)*sample.sd1^2 + (sample.size.2-1)*sample.sd2^2)/(sample.size.pooled-2))
sample.sd.pooled
sample.sd1
sample.sd2
std.err.pooled <- sample.sd.pooled*sqrt(1/sample.size.1+1/sample.size.2)
sample.sd.pooled
std.err.pooled <- sample.sd.pooled*sqrt(1/sample.size.1+1/sample.size.2)
std.err.pooled <- sample.sd.pooled*sqrt(1/sample.size.1+1/sample.size.2)
sample.data.1 <- rnorm(15,55,10)
sample.data.2 <- rnorm(10,45,10)
sample.size.1 <- length(sample.data.1)
sample.size.2 <- length(sample.data.2)
sample.size.pooled <- length(sample.data.1) + length(sample.data.2)
sample.mean1 <- mean(sample.data.1)
sample.mean2 <- mean(sample.data.2)
sample.sd1 <- sd(sample.data.1)
sample.sd2 <- sd(sample.data.2)
sample.sd.pooled <- sqrt(((sample.size.1-1)*sample.sd1^2 + (sample.size.2-1)*sample.sd2^2)/(sample.size.pooled-2))
std.err.pooled <- sample.sd.pooled*sqrt(1/sample.size.1+1/sample.size.2)
t.stat <- (sample.mean1-sample.mean2)/std.err.pooled
t.stat
p.val <- (1-pt(abs(t.stat),sample.size.pooled-2))*2   #
p.val
t.test(sample.data.1,sample.data.2)   # should get the same answer!
t.test(sample.data.1,sample.data.2,var.equal = T)   # should get the same answer!
p.val
rmd2rscript <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- "echo"
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript("LECTURE1.Rmd")
rmd2rscript("LECTURE2.Rmd")
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
## Chi squared goodness-of-fit example
birthdays.bymonth <- c(40,23,33,39,28,29,45,31,22,34,44,20)
months <- c("Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec")
names(birthdays.bymonth) <- months
sample.size <- sum(birthdays.bymonth)
k = length(birthdays.bymonth)   # number of categories (months)
exp.birthdays.bymonth <- sample.size*rep(1/k,times=k)
Chisq.stat <- sum((birthdays.bymonth-exp.birthdays.bymonth)^2/exp.birthdays.bymonth)
Chisq.stat
## View the summary statistic along with its sampling distribution under the null hypothesis
curve(dchisq(x,k-1),0,75)
abline(v=Chisq.stat,col="green",lwd=3)
p <- 1-pchisq(Chisq.stat,k-1)
p
### use R's built in chi squared function
chisq.test(birthdays.bymonth)     # should get the same p value!
## Chi squared goodness-of-fit example
birthdays.bymonth <- c(40,23,33,39,28,29,45,31,22,34,44,20)
months <- c("Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec")
names(birthdays.bymonth) <- months
sample.size <- sum(birthdays.bymonth)
k = length(birthdays.bymonth)   # number of categories (months)
exp.birthdays.bymonth <- sample.size*rep(1/k,times=k)   # compute the expected number under the null hypothesis.
Chisq.stat <- sum((birthdays.bymonth-exp.birthdays.bymonth)^2/exp.birthdays.bymonth)
Chisq.stat
## View the summary statistic along with its sampling distribution under the null hypothesis
curve(dchisq(x,k-1),0,75)
abline(v=Chisq.stat,col="green",lwd=3)
p <- 1-pchisq(Chisq.stat,k-1)
p
### use R's built in chi squared function
chisq.test(birthdays.bymonth)     # should get the same p value!
(birthdays.bymonth-exp.birthdays.bymonth)^2/exp.birthdays.bymonth
curve(dchisq(x,k-1),0,75)
abline(v=Chisq.stat,col="green",lwd=3)
p <- 1-pchisq(Chisq.stat,k-1)
p
chisq.test(birthdays.bymonth)     # should get the same p value!
p
curve(dnorm(x),-3,3)    # we assume that the z statistic is normally distributed- standard normal!
pnorm(1)
pnorm(1)-pnorm(-1)
pnorm(1)-pnorm(-1)
curve(dnorm(x,-3,3))
curve(dnorm(x),-3,3)
abline(v=c(-1,1))
pnorm(0.5)
pnorm(2)-pnorm(-2)
#################
# Discrete probability distributions
mean <- 5
rpois(10,mean)    # note: the random numbers sampled from this distribution have no decimal component
# plot discrete probabilities of getting particular outcomes!
xvals <- seq(0,15,1)
probs <- dpois(xvals,lambda=mean)
names(probs) <- xvals
barplot(probs,ylab="Probability Mass",main="Poisson distribution (discrete)")
barplot(cumsum(probs),ylab="Cumulative Probability",main="Poisson distribution (discrete)")   # cumulative distribution
sum(probs)   # just to make sure it sums to 1!  Does it???
#################
# Discrete probability distributions
mean <- 5
rpois(10,mean)    # note: the random numbers sampled from this distribution have no decimal component
# plot discrete probabilities of getting particular outcomes!
xvals <- seq(0,15,1)
probs <- dpois(xvals,lambda=mean)
names(probs) <- xvals
barplot(probs,ylab="Probability Mass",main="Poisson distribution (discrete)")
barplot(cumsum(probs),ylab="Cumulative Probability",main="Poisson distribution (discrete)")   # cumulative distribution
sum(probs)   # just to make sure it sums to 1!  Does it???
#########
# continuous distributions
shape1 = 0.5
shape2 = 0.5
rbeta(10,shape1,shape2)   # generate 10 random numbers from a continuous distribution
curve(dbeta(x,shape1,shape2),ylab="probability density",xlab="possibilities")   # probability density function (PDF)
curve(pbeta(x,shape1,shape2),ylab="cumulative probability",xlab="possibilities")   # cumulative distribution
integrate(f=dbeta,lower=0,upper=1,shape1=shape1,shape2=shape2)    # just to make sure it integrates to 1!!
rmd2rscript("LECTURE1.Rmd")
rmd2rscript("LECTURE2.Rmd")
## probability mass function example
x <- barplot(sapply(0:10,function(t) dpois(t,2)),xlab="possibilities",ylab='probability')
axis(1,at=x,labels=0:10)
rmd2rscript("LECTURE2.Rmd")
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
### two sample t-test
sample.data.1 <- rnorm(15,55,10)
sample.data.2 <- rnorm(10,45,10)
sample.size.1 <- length(sample.data.1)
sample.size.2 <- length(sample.data.2)
sample.size.pooled <- length(sample.data.1) + length(sample.data.2)
sample.mean1 <- mean(sample.data.1)
sample.mean2 <- mean(sample.data.2)
sample.sd1 <- sd(sample.data.1)
sample.sd2 <- sd(sample.data.2)
sample.sd.pooled <- sqrt(((sample.size.1-1)*sample.sd1^2 + (sample.size.2-1)*sample.sd2^2)/(sample.size.pooled-2))
std.err.pooled <- sample.sd.pooled*sqrt(1/sample.size.1+1/sample.size.2)
t.stat <- (sample.mean1-sample.mean2)/std.err.pooled
t.crit <- abs(qt(0.025,sample.size-1))   # for 2-tailed test
p.val <- (1-pt(abs(t.stat),sample.size.pooled-2))*2   #
### alternatively use the t.test function:
t.test(sample.data.1,sample.data.2,var.equal = T)   # should get the same answer!
p.val
### two sample t-test
sample.data.1 <- rnorm(15,55,10)
sample.data.2 <- rnorm(10,45,10)
sample.size.1 <- length(sample.data.1)
sample.size.2 <- length(sample.data.2)
sample.size.pooled <- length(sample.data.1) + length(sample.data.2)
sample.mean1 <- mean(sample.data.1)
sample.mean2 <- mean(sample.data.2)
sample.sd1 <- sd(sample.data.1)
sample.sd2 <- sd(sample.data.2)
sample.sd.pooled <- sqrt(((sample.size.1-1)*sample.sd1^2 + (sample.size.2-1)*sample.sd2^2)/(sample.size.pooled-2))
std.err.pooled <- sample.sd.pooled*sqrt(1/sample.size.1+1/sample.size.2)
t.stat <- (sample.mean1-sample.mean2)/std.err.pooled
t.crit <- abs(qt(0.025,sample.size-1))   # for 2-tailed test
p.val <- (1-pt(abs(t.stat),sample.size.pooled-2))*2   #
### alternatively use the t.test function:
t.test(sample.data.1,sample.data.2,var.equal = T)   # should get the same answer!
p.val
rmd2rscript("LECTURE1.Rmd")
rmd2rscript("LECTURE2.Rmd")
